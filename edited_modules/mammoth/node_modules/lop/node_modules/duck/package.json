{
  "name": "duck",
  "version": "0.1.11",
  "author": {
    "name": "Michael Williamson",
    "email": "mike@zwobble.org"
  },
  "description": "Rich matchers inspired by Hamcrest. Useful for generating helpful assertion failure messages in tests.",
  "license": "BSD",
  "repository": {
    "type": "git",
    "url": "https://github.com/mwilliamson/duck.js.git"
  },
  "keywords": [
    "test",
    "assert",
    "matcher",
    "assertThat"
  ],
  "dependencies": {
    "underscore": "~1.4.4"
  },
  "devDependencies": {
    "nodeunit": "~0.8.0"
  },
  "readme": "# duck.js -- rich matchers with helpful messages on match failure\n\nduck.js allows you to perform assertions on complex objects.\nWhen those assertions fail, duck.js will try to produce helpful error messages.\nFor instance, suppose you want to assert the same property on an array of objects:\n\n```javascript\nvar duck = require(\"duck\");\nvar isArray = duck.isArray;\nvar hasProperties = duck.hasProperties;\n\nvar users = fetchUsers();\nduck.assertThat(users, isArray([\n    hasProperties({name: \"Bob\"}),\n    hasProperties({name: \"Jim\"}),\n]));\n```\n\nwhich might produce an error message like:\n\n```\nExpected [object with properties {\n    name: 'Bob'\n}, object with properties {\n    name: 'Jim'\n}]\nbut element at index 0 didn't match:\n    value of property \"name\" didn't match:\n        was 'Jim'\n        expected 'Bob'\n    expected object with properties {\n        name: 'Bob'\n    }\nelement at index 1 didn't match:\n    value of property \"name\" didn't match:\n        was 'Bob'\n        expected 'Jim'\n    expected object with properties {\n        name: 'Jim'\n    }\n```\n\n## API\n\nThe below is a quick reference to the API.\nFor more examples, take a look at the tests.\n\n### duck.assertThat(value, matcher)\n\nAssert that `value` satifies `matcher`.\n\nIf `value` satifies `matcher`, return normally, otherwise throw an\nAssertionError describing the mismatch.\n\n### duck.is(value)\n\nIf `value` is a matcher, return that matcher,\notherwise return `duck.equalTo(value)`.\n\n### duck.equalTo(value)\n\nMatcher for deep equality on `value`.\n\n### duck.isObject(matcherObj)\n\nAn object `obj` matches `duck.isObject(matcherObj)` if:\n\n* `obj` matches `duck.hasProperties(matcherObj)`, and\n* there is no key that is present in `obj` but not in `matcherObj`\n\nSample usage:\n\n```javascript\nduck.isObject({\n    name: \"Bob\",\n    address: duck.isObject({\n        city: \"Cambridge\",\n        county: \"UK\"\n    })\n})\n```\n\n`duck.is` is called on each value of the matcher object, meaning that the\nabove is equivalent to:\n\n```javascript\nduck.isObject({\n    name: duck.is(\"Bob\"),\n    address: duck.isObject({\n        city: duck.is(\"Cambridge\"),\n        county: duck.is(\"UK\")\n    })\n})\n```\n\n### duck.hasProperties(matcherProperties)\n\nAn object `obj` matches `duck.hasProperties(matcherProperties)` if,\nfor each `key` in `matcherProperties`, `matcherProperties[key].matches(obj[key])`\n\nSample usage:\n\n```javascript\nduck.hasProperties({\n    name: \"Bob\",\n    address: duck.hasProperties({\n        city: \"Cambridge\",\n        county: \"UK\"\n    })\n})\n```\n\n`duck.is` is called on each value of the matcher object, meaning that the\nabove is equivalent to:\n\n```javascript\nduck.hasProperties({\n    name: duck.is(\"Bob\"),\n    address: duck.hasProperties({\n        city: duck.is(\"Cambridge\"),\n        county: duck.is(\"UK\")\n    })\n})\n```\n\n### duck.isArray(matcherArray)\n\nAn array `blah` matches `duck.isArray(matcherArray)` if:\n\n* `blah.length == matcherArray.length`, and\n* For `0 <= i < array.length`, `matcherArray[i].matches(blah[i])`\n\nSample usage:\n\n```javascript\nduck.isArray([\n    duck.hasProperties({name: \"Bob\"}),\n    duck.hasProperties({name: \"Jim\"}),\n]))\n```\n\n`duck.is` is called on each element of the matcher array, meaning that the\nfollowing are equivalent:\n\n```javascript\nduck.isArray([\"apple\", \"banana\"])\n\nduck.isArray([duck.is(\"apple\"), duck.is(\"banana\")])\n```\n\n### Matcher\n\nEach matcher has the following methods:\n\n#### matcher.matches(value)\n\nReturn `true` if `value` satifies this matcher, false otherwise.\n\n#### matcher.describeMismatch(value)\n\nGenerate a string describing why `value` doesn't satisfy this matcher.\nBehaviour is undefined if `value` actually satisifies the matcher.\n\n#### matcher.matchesWithDescription(value)\n\nEquivalent to:\n\n```javascript\nvar isMatch = this.matches(value);\nreturn {\n    matches: isMatch,\n    description: isMatch ? \"\" : this.describeMismatch(value)\n};\n```\n\nUseful if you're likely to want both the boolean and the mismatch description.\n\n#### matcher.describeSelf()\n\nGenerate a string describing the matcher.\n\n## Thanks\n\nThanks to [Hamcrest](http://hamcrest.org/) for inspiration.\n",
  "readmeFilename": "README.md",
  "_id": "duck@0.1.11",
  "dist": {
    "shasum": "3adc1a3d2fbdd5879ffd3bda05ce0f69355e9093",
    "tarball": "http://registry.npmjs.org/duck/-/duck-0.1.11.tgz"
  },
  "_from": "duck@~0.1.11",
  "_npmVersion": "1.2.14",
  "_npmUser": {
    "name": "mwilliamson",
    "email": "mike@zwobble.org"
  },
  "maintainers": [
    {
      "name": "mwilliamson",
      "email": "mike@zwobble.org"
    }
  ],
  "directories": {},
  "_shasum": "3adc1a3d2fbdd5879ffd3bda05ce0f69355e9093",
  "_resolved": "https://registry.npmjs.org/duck/-/duck-0.1.11.tgz"
}
